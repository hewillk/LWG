<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4399" status="New">
<title>`enable_nonlocking_formatter_optimization` for `pair` and `tuple` needs `remove_cvref_t`</title>
<section><sref ref="[format.tuple]"/></section>
<submitter>Tomasz Kami≈Ñski</submitter>
<date>02 Oct 2025</date>
<priority>99</priority>

<discussion>
<p>
The `enable_nonlocking_formatter_optimization` variable template is specialized only for <i>cv</i>-unqualified 
types. However, the specialization for `pair` and `tuple` does not remove the references and 
<i>cv</i>-qualifiers from the elements:
</p>
<blockquote><pre>
template&lt;class... Ts&gt; 
  constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
    (enable_nonlocking_formatter_optimization&lt;Ts&gt; &amp;&amp; ...);
</pre></blockquote>
<p>
As consequence <tt>pair&lt;const std::string, int&gt;</tt> or 
<tt>pair&lt;const std::string&amp;, int&amp;&gt;</tt> (`map` and `flat_map` reference types) 
will not use unbuffered prints.
<p/>
The proposed wording has recently been implemented in 
<a href="https://gcc.gnu.org/pipermail/libstdc++/2025-October/063758.html">gcc's libstdc++</a>.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[format.tuple]"/> as indicated:</p>

<blockquote>
<p>
-1- For each of `pair` and `tuple`, the library provides the following formatter specialization 
where <tt><i>pair-or-tuple</i></tt> is the name of the template:
</p>
<blockquote>
<pre>
namespace std {
  [&hellip;]
  
  template&lt;class... Ts&gt; 
    constexpr bool enable_nonlocking_formatter_optimization&lt;<i>pair-or-tuple</i>&lt;Ts...&gt;&gt; = 
      (enable_nonlocking_formatter_optimization&lt;<ins>remove_cvref_t&lt;</ins>Ts<ins>&gt;</ins>&gt; &amp;&amp; ...);
}
</pre>
</blockquote>
</blockquote>
</li>
</ol>

</resolution>

</issue>
