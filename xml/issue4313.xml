<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4313" status="New">
<title>Uses-allocator construction of `pair` in `tuple`'s `allocator_arg_t` constructors</title>
<section>
<sref ref="[tuple.cnstr]"/>
</section>
<submitter>Jiang An</submitter>
<date>07 Aug 2025</date>
<priority>99</priority>

<discussion>
<p>
Before <paper num="P0591R4"/>, only `scoped_allocator_adaptor::construct` and 
`polymorphic_allocator::construct` specially handled `pair` for the purpose of uses-allocator 
construction. The primary definition of uses-allocator construction (in e.g., 
<paper num="N4659"/> [allocator.uses.construction]) did not specially handle `pair`. 
The `allocator_arg_t` constructors of `tuple`, which were specified to construct `tuple` 
elements with uses-allocator constructor (per e.g., <paper num="N4659"/> [tuple.cnstr] p26), 
did not specially handle `pair` either.
<p/>
<paper num="P0591R4"/> redefined uses-allocator construction in terms of `make_obj_using_allocator` 
in [allocator.uses.construction] p1 as:
</p>
<blockquote style="border-left: 3px solid #ccc;padding-left: 15px;">
<p>
When applied to the construction of an object of type `T`, it is equivalent to initializing it 
with the value of the expression <tt>make_obj_using_allocator&lt;T&gt;(alloc, args...)</tt>, described below.
</p>
</blockquote>
<p>
And the new definition does handle `pair`. As the specification of `allocator_arg_t` constructors of 
`tuple` (now in <sref ref="[tuple.cnstr]"/> p33) still refer to uses-allocator construction as-is, 
these constructors should construct a `pair` element in a way equivalent to `make_obj_using_allocator` now.
<p/>
The following example shows the behavioral difference.
</p>
<blockquote><pre>
#include &lt;cstddef&gt;
#include &lt;utility&gt;
#include &lt;tuple&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;cassert&gt;

template&lt;class T&gt;
class payload_ator {
  int payload{};
   
public:
  using value_type = T;

  payload_ator() = default;

  constexpr explicit payload_ator(int n) noexcept : payload{n} {}

  template&lt;class U&gt;
  constexpr explicit payload_ator(payload_ator&lt;U&gt; a) noexcept : payload{a.payload} {}  

  friend bool operator==(payload_ator, payload_ator) = default;

  template&lt;class U&gt;
  friend constexpr bool operator==(payload_ator x, payload_ator&lt;U&gt; y) noexcept {
    return x.payload == y.payload;
  }  

  constexpr T* allocate(std::size_t n) { return std::allocator&lt;T&gt;{}.allocate(n); }

  constexpr void deallocate(T* p, std::size_t n) { return std::allocator&lt;T&gt;{}.deallocate(p, n); }  

  constexpr int get_payload() const noexcept { return payload; }
};

bool test() {
  constexpr int in_v = 42;
  using my_pair_t = std::pair&lt;int, std::vector&lt;int, payload_ator&lt;int&gt;&gt;&gt;;
  std::tuple&lt;my_pair_t&gt; t(std::allocator_arg, payload_ator&lt;int&gt;{in_v});
  auto out_v = std::get&lt;0&gt;(t).second.get_allocator().get_payload();
  return in_v == out_v;
}

int main() {
  assert(test()); // <span style="color:#C80000;font-weight:bold">passes only if allocator_arg_t constructors of tuple specially handle pair</span>
}
</pre></blockquote>
<p>
However, the behavioral changes of these constructors were not discussed in <paper num="P0591R4"/>, 
and existing implementations that claim full implementation of <paper num="P0591R4"/> (MSVC STL and libstdc++) 
did not change these constructors (<a href="https://godbolt.org/z/6vnP78nqW">demo</a>).
<p/>
Given that implementations did not recognize changes of `allocator_arg_t` constructors as part of the paper, 
and special handling of `pair` would significantly complicate these constructors, perhaps we should 
explicitly specify that these constructors behave as if special handling for `pair` were missing.
</p>
</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<ol>

<li><p>Modify <sref ref="[tuple.cnstr]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class Alloc&gt;
  constexpr explicit(see below )
    tuple(allocator_arg_t, const Alloc&amp; a);
[&hellip;]
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, pair&lt;U1, U2&gt;&amp;&amp;);
template&lt;class Alloc, class U1, class U2&gt;
  constexpr explicit(<i>see below</i>)
    tuple(allocator_arg_t, const Alloc&amp; a, const pair&lt;U1, U2&gt;&amp;&amp;);
template&lt;class Alloc, tuple-like UTuple&gt;
  constexpr explicit(<i>see below</i>)
  tuple(allocator_arg_t, const Alloc&amp; a, UTuple&amp;&amp;);
</pre>
<blockquote>
<p>
-32- <i>Preconditions</i>: `Alloc` meets the <i>Cpp17Allocator</i> requirements 
(<sref ref="[allocator.requirements.general]"/>).
<p/>
-33- <i>Effects</i>: Equivalent to the preceding constructors except that each element is constructed 
with uses-allocator construction (<sref ref="[allocator.uses.construction]"/>)<ins>, except that the 
construction behaves as if there were only one `uses_allocator_construction_args` overload and the 
overload behaved the same as the first actual overload without <i>Constraints</i></ins>.
</p>
</blockquote>
</blockquote>

</li>

</ol>
</resolution>

</issue>
