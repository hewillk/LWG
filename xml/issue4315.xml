<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4315" status="Ready">
<title>Insufficient specification of `vector_two_norm` and `matrix_frob_norm`</title>
<section>
<sref ref="[linalg.algs.blas1.nrm2]"/>
<sref ref="[linalg.algs.blas1.matfrobnorm]"/>
</section>
<submitter>Mark Hoemmen</submitter>
<date>14 Aug 2025</date>
<priority>99</priority>

<discussion>
<p>
The Returns clauses of `vector_two_norm` <sref ref="[linalg.algs.blas1.nrm2]"/> and
`matrix_frob_norm` <sref ref="[linalg.algs.blas1.matfrobnorm]"/> say that the
functions return the "square root" of the sum of squares of the initial value and 
the absolute values of the elements of the input `mdspan`. However, nowhere in 
<sref ref="[linalg]"/> explains how to compute a square root.
</p>
<ol>
<li><p>The input `mdspan`'s `value_type` and the initial value type are
not constrained in a way that would ensure that calling `std::sqrt` on
this expression would be well-formed.</p></li>
<li><p>There is no provision to find `sqrt` via argument-dependent lookup,
even though <sref ref="[linalg]"/> has provisions to find `abs`, `conj`, `real`, and
`imag` via argument-dependent lookup. There is no "<tt><i>sqrt-if-needed</i></tt>"
analog to <tt><i>abs-if-needed</i></tt>, <tt><i>conj-if-needed</i></tt>, 
<tt><i>real-if-needed</i></tt>, and <tt><i>imag-if-needed</i></tt>.</p></li>
</ol>
<p>
The easiest fix for both issues is just to <i>Constrain</i> both `Scalar` and
the input `mdspan`'s `value_type` to be floating-point numbers or
specializations of `std::complex` for these two functions. This
presumes that relaxing this <i>Constraint</i> and fixing the above two issues
later would be a non-breaking change. If that is <em>not</em> the case, then
I would suggest removing the two functions entirely.
</p>
<superseded>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As a drive-by fix the proposed wording adds a missing closing parentheses in 
<sref ref="[linalg.algs.blas1.nrm2]"/> p2.]
</p>
</blockquote>

<ol>

<li><p>Modify <sref ref="[linalg.algs.blas1.nrm2]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(InVec v, Scalar init);
template&lt;class ExecutionPolicy, <i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(ExecutionPolicy&amp;&amp; exec, InVec v, Scalar init);
</pre>
<blockquote>
<p>
-1- [<i>Note 1</i>: [&hellip;] &mdash; <i>end note</i>]
<p/>
<ins>-?- <i>Constraints</i>: `InVec::value_type` and `Scalar` are either a floating-point type, or
a specialization of `complex`.</ins>
<p/>
-2- <i>Mandates</i>: Let `a` be <tt><i>abs-if-needed</i>(declval&lt;typename InVec::value_type&gt;())</tt>. 
Then, <tt>decltype(init + a * a<ins>)</ins></tt> is convertible to `Scalar`.
<p/>
-3- <i>Returns</i>: The square root of the sum of the square of `init` and the squares of the 
absolute values of the elements of `v`.
<p/>
[<i>Note 2</i>: For `init` equal to zero, this is the Euclidean norm (also called 2-norm) of the vector 
`v`. &mdash; <i>end note</i>]
<p/>
-4- <i>Remarks</i>: If <del>`InVec::value_type`, and `Scalar` are all floating-point types or specializations of `complex`,
and if</del> `Scalar` has higher precision than `InVec::value_type`, then intermediate terms in the sum use
`Scalar`'s precision or greater.
<p/>
[<i>Note 3</i>: An implementation of this function for floating-point types `T` can use the `scaled_sum_of_squares`
result `from vector_sum_of_squares(x, {.scaling_factor=1.0, .scaled_sum_of_squares=init})`. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify <sref ref="[linalg.algs.blas1.matfrobnorm]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>in-matrix</i> InMat, class Scalar&gt;
  Scalar matrix_frob_norm(InMat A, Scalar init);
template&lt;class ExecutionPolicy, <i>in-matrix</i> InMat, class Scalar&gt;
  Scalar matrix_frob_norm(ExecutionPolicy&amp;&amp; exec, InMat A, Scalar init);
</pre>
<blockquote>
<p>
<ins>-?- <i>Constraints</i>: `InVec::value_type` and `Scalar` are either a floating-point type, or
a specialization of `complex`.</ins>
<p/>
-2- <i>Mandates</i>: Let `a` be <tt><i>abs-if-needed</i>(declval&lt;typename InMat::value_type&gt;())</tt>. 
Then, <tt>decltype(init + a * a)</tt> is convertible to `Scalar`.
<p/>
-3- <i>Returns</i>: The square root of the sum of squares of `init` and the absolute values 
of the elements of `A`.
<p/>
[<i>Note 2</i>: For `init` equal to zero, this is the Frobenius norm of the matrix `A`. &mdash; <i>end note</i>]
<p/>
-4- <i>Remarks</i>: If <del>`InMat::value_type` and `Scalar` are all floating-point types or specializations of 
`complex`, and if</del> `Scalar` has higher precision than `InMat::value_type`, then intermediate terms in the 
sum use `Scalar`'s precision or greater.
</p>
<blockquote><pre>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>
</superseded>

<note>LWG telecon 2025-10-10; Update proposed resolution after review</note>
<p>
Use <i>Mandates</i>: for the new requirements, because we plan to change
this later so want to make it ill-formed, not something that is statically
checkable as part of the API.
</p>

<note>LWG telecon 2025-10-10; Status updated New &rarr; Ready</note>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N5014"/>.
</p>

<blockquote class="note">
<p>
[<i>Drafting note:</i> As a drive-by fix the proposed wording adds a missing closing parentheses in 
<sref ref="[linalg.algs.blas1.nrm2]"/> p2.]
</p>
</blockquote>

<ol>

<li><p>Modify <sref ref="[linalg.algs.blas1.nrm2]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(InVec v, Scalar init);
template&lt;class ExecutionPolicy, <i>in-vector</i> InVec, class Scalar&gt;
  Scalar vector_two_norm(ExecutionPolicy&amp;&amp; exec, InVec v, Scalar init);
</pre>
<blockquote>
<p>
-1- [<i>Note 1</i>: [&hellip;] &mdash; <i>end note</i>]
<p/>
-2- <i>Mandates</i>:
<ins>`InVec::value_type` and `Scalar` are either a floating-point type, or
a specialization of `complex`.</ins>
Let `a` be <tt><i>abs-if-needed</i>(declval&lt;typename InVec::value_type&gt;())</tt>. 
Then, <tt>decltype(init + a * a<ins>)</ins></tt> is convertible to `Scalar`.
<p/>
-3- <i>Returns</i>: The square root of the sum of the square of `init` and the squares of the 
absolute values of the elements of `v`.
<p/>
[<i>Note 2</i>: For `init` equal to zero, this is the Euclidean norm (also called 2-norm) of the vector 
`v`. &mdash; <i>end note</i>]
<p/>
-4- <i>Remarks</i>: If <del>`InVec::value_type`, and `Scalar` are all floating-point types or specializations of `complex`,
and if</del> `Scalar` has higher precision than `InVec::value_type`, then intermediate terms in the sum use
`Scalar`'s precision or greater.
<p/>
[<i>Note 3</i>: An implementation of this function for floating-point types `T` can use the `scaled_sum_of_squares`
result `from vector_sum_of_squares(x, {.scaling_factor=1.0, .scaled_sum_of_squares=init})`. &mdash; <i>end note</i>]
</p>
</blockquote>
</blockquote>

</li>

<li><p>Modify <sref ref="[linalg.algs.blas1.matfrobnorm]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;<i>in-matrix</i> InMat, class Scalar&gt;
  Scalar matrix_frob_norm(InMat A, Scalar init);
template&lt;class ExecutionPolicy, <i>in-matrix</i> InMat, class Scalar&gt;
  Scalar matrix_frob_norm(ExecutionPolicy&amp;&amp; exec, InMat A, Scalar init);
</pre>
<blockquote>
<p>
-2- <i>Mandates</i>:
<ins>`InVec::value_type` and `Scalar` are either a floating-point type, or
a specialization of `complex`.</ins>
Let `a` be <tt><i>abs-if-needed</i>(declval&lt;typename InMat::value_type&gt;())</tt>. 
Then, <tt>decltype(init + a * a)</tt> is convertible to `Scalar`.
<p/>
-3- <i>Returns</i>: The square root of the sum of squares of `init` and the absolute values 
of the elements of `A`.
<p/>
[<i>Note 2</i>: For `init` equal to zero, this is the Frobenius norm of the matrix `A`. &mdash; <i>end note</i>]
<p/>
-4- <i>Remarks</i>: If <del>`InMat::value_type` and `Scalar` are all floating-point types or specializations of 
`complex`, and if</del> `Scalar` has higher precision than `InMat::value_type`, then intermediate terms in the 
sum use `Scalar`'s precision or greater.
</p>
<blockquote><pre>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>

</resolution>

</issue>
